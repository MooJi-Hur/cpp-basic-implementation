### 원래 구상했던 풀이 방법
- 실수 부분을 정수로 출력해야 함
- 전체 값에서 정수를 빼서 실수 부분을 구함
- 실수에 10을 곱하면서 자릿수를 올림
- floor(실수)를 버림한 값과 실수 값이 일치할 때 정수의 값과 동일하다고 판단

### 문제점
- 소숫점 이하 자리수가 없음에도 fractionalPart와 floor(fractionalPart)의 값이 동일하지 않은 경우가 있음 
- 즉 floor가 예상대로 동작하지 않음, int로 형 변환을 해도 마찬가지
- 입력값 : 1.414213, 소수점 이하 실수 부분 : 0.414213
- 10씩 곱한 값과 1의 자리에서 버린 값
    ```
    0.414213 0
    4.14213 4
    41.4213 41
    414.213 414
    4142.13 4142
    41421.3 41421
    414213 414212 <- 실수 부분과 정수에서 내린 값이 달라진 지점
    4142130 4142129
    ```
- `<iomanip>`라이브러리를 이용해 fractionalPart의 소숫점 이하 값도 출력해봄
    ```
    0.414213 
    4.142130 
    41.421299 <- 이전 값에서 10을 곱했지만, 41.421300이 아님
    414.212982 
    4142.129883 
    41421.296875 
    414212.968750 
    4142129.750000 
    ```
- 정밀도의 문제. 소숫점을 표현할 공간의 크기에 따라 값이 달라지고 있음 

### 실습을 통한 이해
- 
    ```c++
    // 3.141529f == (float)(3.141529083F)
    // 3.141529 == (double)(3.141528999999999794)
    // 3.141529l == (long double)(3.141528999999999794L)
    float floatValue = 3.141529;
    double doubleValue = 3.141529;
    cout << "floatValue  : " << floatValue << endl;
    cout << "doubleValue : " << doubleValue << endl;
    cout << "두 값의 차이가 0이면 1, 아니면 0을 출력 : "
         << ((floatValue - doubleValue) == 0) << endl;
    cout << setprecision(8) << "floatValue  : " << floatValue << endl;
    cout << setprecision(8) << "doubleValue : " << doubleValue << endl;
    ```

- 결과
    - `<iomanip>`를 이용한 처리가 없으면 소숫점 이하 다섯째 자리까지만 출력
    - `float`은 소숫점 이하 여서일곱째 자리까지 표현할 수 있음
    - 정밀도를 8로 설정
      - `float`은 범위를 넘어섰으며, 처음 입력한 값과 다른 값을 출력
      - `double`은 입력한 값 그대로 출력하고 있음  
    ```
    floatValue  : 3.14153  
    doubleValue : 3.14153
    두 값의 차이가 0이면 1, 아니면 0을 출력 : 0
    floatValue  : 3.1415291
    doubleValue : 3.141529   
    ```
